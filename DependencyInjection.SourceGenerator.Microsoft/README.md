# DependencyInjection.SourceGenerator.Microsoft
Register services using attributes instead of registering in code.

## Usage
Add the "Register" attribute to the class you want to register. The attribute takes a type and a lifetime. The type is the type you want to register and the lifetime is the lifetime of the service. The lifetime is optional and defaults to Transient.

```csharp

namespace RootNamespace.Services;

public interface IExampleService
{
	string GetExample();
}

public interface IAnotherService
{
	string GetAnother();
}

[Register(ServiceName = "ServiceName", Lifetime = Lifetime.Singleton)]
public class ExampleService : IExampleService
{
	public string GetExample()
	{
		return "Example";
	}
}

[Decorate]
public class KeyedService : IExampleService
{
	public string GetExample()
	{
		return "Keyed";
	}
}

[Decorator]
public class ServiceDecorator : IExampleService
{
	private readonly IExampleService _exampleService;

	public ServiceDecorator(IExampleService exampleService)
	{
		_exampleService = exampleService;
	}

	public string GetExample()
	{
		return _exampleService.GetExample();
	}
}

[Register<IAnotherService>]
public class MultipleInterfacesService : IExampleService, IAnotherService
{
	public string GetExample()
	{
		return "MultipleInterfaces";
	}

	public string GetAnother()
	{
		return "Another";
	}
}

```


Generates a class ServiceCollectionExtensions
Assuming the project is named MyProject, the generated method will be named AddMyProject.

```csharp
// <auto-generated/>
#pragma warning disable
#nullable enable
namespace RootNamespace;
using global::Microsoft.Extensions.DependencyInjection;

[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
public static class ServiceCollectionExtensions
{
    public static global::Microsoft.Extensions.DependencyInjection.IServiceCollection AddMyProject(this global::Microsoft.Extensions.DependencyInjection.IServiceCollection services)
    {
        services.AddKeyedSingleton<global::RootNamespace.Services.IExampleService, global::RootNamespace.Services.ExampleService>("ServiceName");
        services.Decorate<global::RootNamespace.Services.IExampleService, global::RootNamespace.Services.ServiceDecorator>();
        services.AddTransient<global::RootNamespace.Services.IAnotherService, global::RootNamespace.Services.MultipleInterfacesService>();
        return services;
    }
}
```

This can then be used like this: 
```csharp
var services = new ServiceCollection();
services.AddMyProject();
```

for AspNetCore web APIs:
```csharp
public void ConfigureServices(IServiceCollection services)
{
	services.AddMyProject();
}
```

and for minimal APIs:

```csharp
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddMyProject();
```

You can also create a method that will be called by the AddMyProject method. This is useful if you want to register services from other libraries

```csharp
using global::DependencyInjection.SourceGenerator.Contracts.Attributes;

namespace DependencyInjection.SourceGenerator.Microsoft.Demo;

public class Registrator
{
    [RegistrationExtension]
    internal static void Register(global::Microsoft.Extensions.DependencyInjection.IServiceCollection services)
    {
		// Register your additional services here
    }
}
```

This will then produce the following code:

```csharp
public static class ServiceCollectionExtensions
{
    public static global::Microsoft.Extensions.DependencyInjection.IServiceCollection AddTestProject(this global::Microsoft.Extensions.DependencyInjection.IServiceCollection services)
    {
        global::DependencyInjection.SourceGenerator.Microsoft.Demo.Registrator.Register(services);
        return services;
    }
}
```

## Lifetime
The lifetime is an enum with the following values:
- Transient
- Scoped
- Singleton